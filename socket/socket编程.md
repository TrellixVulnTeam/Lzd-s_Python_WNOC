## 本地主机可以和云服务器socket通信?

+ 配置如下的防火墙规则

![](https://gitee.com/lzd-1230/img-host/raw/master/image/20210925195947.png)

然后`socket`服务端监听本机“0.0.0.0:9000”,然后主机去访问公网IP的9000端口即可完成。

## socket 基础

### 套接字分类

+ 基于文件类型的套接字`AF_UNIX`

基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信

+ 基于网络的套接字`AF_INET`

是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用`AF_INET`。暂时我只用到这么多，以后还有其它的再更新…

### 半链接池

> `listen(n)`中的n相当于一个接待室容量,当客户端接入后,首先会呆在这里面,等待`accept()`方法将其接收走。

```python
 # 3.设置为listen模式
    tcp_server.listen(128)
    while True:
        # 4.等待连接,来一个连接创建一个进程去处理
        print("----waiting for connect----")
        client_socket,client_addr = tcp_server.accept()
        # ...服务代码
        
# 如果服务代码的时间过长,则回来接待室接人的速度就会变慢,一旦接待室人满了,下一个人的connect就连不上来了
# 因此可以使用多任务的方式,将服务代码给另一个线程/进程来运行,自己马上回去接人
```

### 服务端和客户端实现流程

![img](https://images.cnblogs.com/cnblogs_com/goodcandle/socket3.jpg)

### 远程执行命令->粘包问题

+ 粘包问题:上一次`recv`没收干净,仍有一些数据留在了本地的缓存中。导致后面接收的数据的结果错误

+ 粘包问题出现的原因：

  ①：TCP是流式协议，数据向水流一样，相互之间没有边界

  ```python
  server_socket.send(b"Hello")
  server_socket.send(b"World")
  ```

  由于两个send的时间间隔非常短,因此Nagle协议会将两个数据打包成一次发出.

  ②：接收时候大小是一个固定值。

  ​	由于接收数据时**没有获得到文件的总大小**,因此接受的时候无法调控

+ 如何解决？

  > 每次收数据的时候收干净

  + 可以简单地把recv中的参数调大吗？

    答：并不行，因为`socket.recv(1024)`是指从缓冲区中取得1024B的数据,这个数值的上限是缓冲区的大小 
    
  + 

###  UDP不存在粘包

+ UDP协议的发送单位

  UDP协议发送的内容是以消息为单位,而不是以流为单位.一个`send`就是一个消息,其之间有着明确的边界!

+ UDP协议的接收逻辑

  当接收的字节数目小于缓冲区内的子节数时,缓冲区会把多出的字节全部扔掉,这样就不会破坏下一条消息的完整性.

## 虚拟网络

### 几种虚拟机常见的模式

+ 桥接模式

  相当于在路由器上面再连接了一个主机。它的地位和你的主机是一样的，因此它们属于一个子网。比如你在家开虚拟机桥接模式构建了一个网站，那么你家里的Wifi下，都可以直接访问这个网站

+ NAT模式

  相当于利用了一个虚拟的路由连接到了主机的网卡，然后下面再通过`NAT `原理可以连接多个虚拟网卡。

  其中`NAT`相当于让多台设备使用同一个公网IP,使得每一台主机称为一个公网IP下的一个随机端口。收发数据时,路由器随机产生一个端口号,该端口号接受的数据都被转发到该主机中