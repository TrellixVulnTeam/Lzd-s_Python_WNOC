## 多进程概念

### 进程的概念理解

+ 一个CPU正在执行的`任务`+其所有的`资源(上下文)`

### 并发与并行

+ 并发:伪并行,指一个CPU核使用多道技术执行多个任务,每个执行一点,然后保存上下文之后去执行另一个,由于执行速度较快,看起来也像是同时运行的

+ 并行:计算机拥有多核,可以同一时刻执行多个任务

  > 在并行下也可以存在并发,如:当CPU1手头的任务遇到了I/O操作阻塞,可以先挂起去执行其它的进程。

### 同步与异步

> 同步和异步，指的是程序调用函数的方式，同步指的是我执行这个函数，就得等到该函数的`return`语句返回为止,如果函数一直在等待IO,那么我程序也就卡在那里同步等着
>
> 异步指的是调用了函数之后,我接着往下执行,等到那个函数结果返回了之后,通过**事件或者通知的方式**告诉我,我再拿到这个值,在此之前,我都去干别的事情

### 阻塞与非阻塞

+ 阻塞:调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作）。函数只有在得到结果之后才会将阻塞的线程激活。

```python
#1. 同步调用：apply一个累计1亿次的任务，该调用会一直等待，直到任务返回结果为止，但并未阻塞住（即便是被抢走cpu的执行权限，那也是处于就绪态）;
#2. 阻塞调用：当socket工作在阻塞模式的时候，如果没有数据的情况下调用recv函数，则当前线程就会被挂起，直到有数据为止,其中CPU并未进行像同步调用中那些计算
```

### 关于进程的创建

1. 系统初始化（查看进程linux中用`ps`命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）

2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，`os.fork`,`subprocess.Popen`等）

3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）

4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）

------

无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的：

1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）

2. 在windows中该系统调用是：`CreateProcess`，`CreateProcess`既处理进程的创建，也负责把正确的程序装入新进程。　

------

关于创建的子进程，UNIX和windows

1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（**多道技术要求物理层面实现进程之间内存的隔离**），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。

2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，**从一开始父进程与子进程的地址空间就是不同的**。

六 进程的终止（了解）

1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用`exit`，在windows中用`ExitProcess`）

2. 出错退出（自愿，python a.py中a.py不存在）

3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）

4. 被其他进程杀死（非自愿，如`kill -9`）

###  进程的层次结构

无论UNIX还是windows，进程只有一个父进程，不同的是：

1. 在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。

2. 在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（**称为句柄**）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。

### 进程的状态

```
tail -f access.log |grep '404'
```

执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道'|'通讯，将tail的结果作为grep的输入。

进程grep在等待输入（即I/O）时的状态称为阻塞，此时grep命令都无法运行

其实在两种情况下会导致一个进程在逻辑上不能运行，

1. 进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作

2. 与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。

因而一个进程有三种状态

![img](https://pic1.zhimg.com/80/v2-1b816bea5d7900ca5faad9abdee1cec4_1440w.jpg)

------

+ 进程的实现原理:其实和单片机上讲的中断基本一致

  当一个任务需要切换的时候,首先保护现场,然后去执行另外的任务即可。

  ![img](https://pic1.zhimg.com/80/v2-c7e653f1793ccc5d2aeed7d128459698_1440w.jpg)

## 多进程实操

### multiprocessing模块基础

+ 创建进程

  ```python
  p = multiprocessing.Process(target = print_name,args=("lzd"))
  # 注:
  	1.调用 multiprocessing.Process时要指定位置参数
  	2.线程的位置参数要使用元组形式传递
  
  # 该函数参数详解
      group参数未使用，值始终为None
      target表示调用对象，即子进程要执行的任务
      args表示调用对象的位置参数元组，args=(1,2,'egon',)
      kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}
      name为子进程的名称
  ```

+ 进程运行中的常用方法

  ```python
      p.start()：启动进程，并调用该子进程中的p.run() 
      # p.run():是利用对象启动进程时会运行的方法,则在类中一定要实现该方法  
      p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
  	p.is_alive():如果p仍然运行，返回True
      p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程
  ```

+ 进程的常用属性

  ```python
  	p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
  	p.name:进程的名称
   
  	p.pid：进程的pid
   
  	p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)
  	p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）
  ```

  ### 进程间的数据隔离

  ```python
  from multiprocessing import Process
  n=100 #在windows系统中应该把全局变量定义在if __name__ == '__main__'之上就可以了
  
  def work():
      global n
      n=0
      print('子进程内: ',n)
  
  if __name__ == '__main__':
      p=Process(target=work)
      p.start()
      p.join() # 等待子进程运行结束,我再来看
      print('主进程内: ',n) 
  ```

  



## 多线程

### 多线程基础

+ 什么是线程?

  

